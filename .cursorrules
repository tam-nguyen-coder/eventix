# Eventix - Cursor Rules

> Scalable Event Booking System using Microservices & Event-Driven Architecture

## Project Overview

Eventix is a high-performance backend system for booking event tickets. It handles high concurrency and ensures data consistency using an event-driven approach with microservices architecture.

## Tech Stack

| Category | Technology | Version |
|----------|------------|---------|
| Runtime | Node.js | 24.x |
| Language | TypeScript | 5.8.x |
| Framework | NestJS | 11.x |
| Monorepo | Nx | 21.x |
| Database | PostgreSQL | 17.x |
| ORM | TypeORM | 0.3.x |
| Message Broker | Redpanda (Kafka-compatible) | latest |
| Auth | Auth0 (JWT/OIDC) | - |
| API Docs | Swagger/OpenAPI | - |
| Infrastructure | Docker & Docker Compose | 27.x |

## Context7 MCP Usage

When you need up-to-date documentation, use Context7 MCP to fetch the latest docs:

### Primary Libraries (Use Frequently)

```
# NestJS - Main framework
resolve-library-id: "nestjs"
get-library-docs: topic="microservices" | "guards" | "modules" | "providers"

# TypeORM - Database ORM
resolve-library-id: "typeorm"
get-library-docs: topic="repository" | "migrations" | "transactions" | "relations"

# Nx - Monorepo tooling
resolve-library-id: "nx"
get-library-docs: topic="workspace" | "generators" | "executors"
```

### Secondary Libraries (Use When Needed)

```
# KafkaJS - For Redpanda/Kafka messaging
resolve-library-id: "kafkajs"
get-library-docs: topic="producer" | "consumer" | "transactions"

# class-validator - DTO validation
resolve-library-id: "class-validator"

# class-transformer - Object transformation
resolve-library-id: "class-transformer"

# Swagger/OpenAPI
resolve-library-id: "nestjs swagger"
```

### When to Use Context7

1. **Before implementing new features** - Fetch latest API patterns
2. **When encountering errors** - Check updated documentation
3. **For best practices** - Get current recommended approaches
4. **Version-specific APIs** - Ensure compatibility with project versions

## Architecture Guidelines

### Clean Architecture Layers

```
┌─────────────────────────────────────┐
│           Presentation              │  ← Controllers, DTOs
├─────────────────────────────────────┤
│           Application               │  ← Use Cases, Services
├─────────────────────────────────────┤
│             Domain                  │  ← Entities, Business Logic
├─────────────────────────────────────┤
│          Infrastructure             │  ← Repositories, External APIs
└─────────────────────────────────────┘
```

### Dependency Rule

- Inner layers MUST NOT depend on outer layers
- Domain layer has NO external dependencies
- Use interfaces/ports for dependency inversion

## Monorepo Structure

```
eventix/
├── apps/
│   ├── api-gateway/           # HTTP entry point, Auth0 validation
│   ├── catalog-service/       # Events, Venues, Seats management
│   ├── booking-service/       # Reservations, Seat locking
│   └── payment-service/       # Payment processing
├── libs/
│   ├── shared-dto/            # Request/Response DTOs
│   └── shared-constants/      # Kafka topics, Error codes
├── docker-compose.yml
└── nx.json
```

## Coding Conventions

### File Naming

```
# NestJS modules
*.module.ts
*.controller.ts
*.service.ts
*.repository.ts
*.entity.ts
*.dto.ts
*.guard.ts
*.interceptor.ts
*.decorator.ts
```

### Class Naming

```typescript
// Controllers - plural noun + Controller
EventsController
BookingsController

// Services - singular noun + Service
EventService
BookingService

// Entities - singular PascalCase
Event
Booking
Venue
Seat

// DTOs - descriptive + Dto
CreateBookingDto
EventResponseDto
```

### Code Style

```typescript
// ✅ Use explicit types
async createBooking(dto: CreateBookingDto): Promise<Booking>

// ✅ Use readonly for injected dependencies
constructor(private readonly bookingService: BookingService) {}

// ✅ Use enums for status values
enum BookingStatus {
  PENDING = 'PENDING',
  CONFIRMED = 'CONFIRMED',
  CANCELLED = 'CANCELLED',
}

// ✅ Use class-validator decorators
export class CreateBookingDto {
  @IsUUID()
  eventId: string;

  @IsArray()
  @IsUUID('4', { each: true })
  seatIds: string[];
}
```

## Database Conventions

### Entity Structure

```typescript
@Entity('bookings')
export class Booking {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ name: 'user_id' })
  userId: string;

  @Column({ type: 'enum', enum: BookingStatus })
  status: BookingStatus;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @Column({ name: 'expires_at', type: 'timestamp' })
  expiresAt: Date;
}
```

### Transaction Handling

```typescript
// ✅ Use QueryRunner for complex transactions
async reserveSeats(dto: CreateBookingDto): Promise<Booking> {
  const queryRunner = this.dataSource.createQueryRunner();
  await queryRunner.connect();
  await queryRunner.startTransaction();
  
  try {
    // Lock seats with pessimistic locking
    const seats = await queryRunner.manager.find(Seat, {
      where: { id: In(dto.seatIds) },
      lock: { mode: 'pessimistic_write' },
    });
    
    // Business logic...
    
    await queryRunner.commitTransaction();
    return booking;
  } catch (error) {
    await queryRunner.rollbackTransaction();
    throw error;
  } finally {
    await queryRunner.release();
  }
}
```

## Event-Driven Patterns

### Kafka Topics (Redpanda)

```typescript
// libs/shared-constants/src/kafka-topics.ts
export const KAFKA_TOPICS = {
  BOOKING_CREATED: 'booking.created',
  BOOKING_CANCELLED: 'booking.cancelled',
  PAYMENT_SUCCESS: 'payment.success',
  PAYMENT_FAILED: 'payment.failed',
} as const;
```

### Event Payloads

```typescript
// libs/shared-dto/src/events/
export interface BookingCreatedEvent {
  bookingId: string;
  userId: string;
  eventId: string;
  amount: number;
  seatIds: string[];
  createdAt: string;
}

export interface PaymentSuccessEvent {
  bookingId: string;
  transactionId: string;
  processedAt: string;
}
```

### Producer Pattern

```typescript
@Injectable()
export class BookingProducer {
  constructor(
    @Inject('KAFKA_SERVICE')
    private readonly kafkaClient: ClientKafka,
  ) {}

  async emitBookingCreated(event: BookingCreatedEvent): Promise<void> {
    await this.kafkaClient.emit(KAFKA_TOPICS.BOOKING_CREATED, event);
  }
}
```

### Consumer Pattern

```typescript
@Controller()
export class PaymentConsumer {
  @EventPattern(KAFKA_TOPICS.BOOKING_CREATED)
  async handleBookingCreated(
    @Payload() event: BookingCreatedEvent,
    @Ctx() context: KafkaContext,
  ): Promise<void> {
    // Process payment...
  }
}
```

## API Design

### RESTful Endpoints

```
# Catalog Service
GET    /events              # List events (paginated)
GET    /events/:id          # Get event details
POST   /events              # Create event (Admin only)
PUT    /events/:id          # Update event (Admin only)
DELETE /events/:id          # Delete event (Admin only)

# Booking Service
POST   /bookings            # Create reservation
GET    /bookings/:id        # Get booking details
GET    /bookings/my         # Get user's bookings
DELETE /bookings/:id        # Cancel booking
```

### Response Format

```typescript
// Success response
{
  "success": true,
  "data": { ... },
  "meta": {
    "page": 1,
    "limit": 10,
    "total": 100
  }
}

// Error response
{
  "success": false,
  "error": {
    "code": "SEAT_ALREADY_RESERVED",
    "message": "One or more seats are already reserved"
  }
}
```

## Error Handling

### Custom Exceptions

```typescript
// libs/shared-constants/src/errors/
export class SeatAlreadyReservedException extends ConflictException {
  constructor(seatIds: string[]) {
    super({
      code: 'SEAT_ALREADY_RESERVED',
      message: 'Seats are already reserved',
      seatIds,
    });
  }
}

export class BookingExpiredException extends GoneException {
  constructor(bookingId: string) {
    super({
      code: 'BOOKING_EXPIRED',
      message: 'Booking has expired',
      bookingId,
    });
  }
}
```

## Testing Guidelines

> ⚠️ **CURRENT PHASE: Testing is DEFERRED**
> 
> To save time and resources during initial development:
> - **DO NOT** create test files (`*.spec.ts`, `*.e2e-spec.ts`)
> - **DO NOT** write unit tests or integration tests
> - **DO NOT** run test commands
> - Focus on implementing core functionality first
> - Tests will be added in a later phase

### Future Testing (Deferred)

Testing will be implemented after core features are stable. Reference patterns will be documented when needed.

## Git Conventions

### Branch Naming

```
feature/TICKET-123-add-seat-reservation
bugfix/TICKET-456-fix-payment-timeout
hotfix/TICKET-789-critical-booking-issue
chore/update-dependencies
```

### Commit Messages

```
feat(booking): implement seat locking mechanism
fix(payment): handle duplicate payment callbacks
docs(api): update swagger documentation
refactor(catalog): extract venue repository
chore(deps): upgrade nestjs to v10
```

## Security Guidelines

### Auth0 JWT Validation

```typescript
// Always validate JWT in Gateway
@UseGuards(AuthGuard('jwt'))
@Controller('bookings')
export class BookingsController {}

// Extract user from token
@Get('my')
async getMyBookings(@CurrentUser() user: JwtPayload) {
  return this.bookingService.findByUserId(user.sub);
}
```

### Input Validation

```typescript
// Always use DTOs with validation
@Post()
async create(@Body() dto: CreateBookingDto) {
  // dto is already validated
}

// Enable global validation pipe
app.useGlobalPipes(new ValidationPipe({
  whitelist: true,
  forbidNonWhitelisted: true,
  transform: true,
}));
```

## Performance Considerations

### Database Indexing

```sql
-- Essential indexes for booking queries
CREATE INDEX idx_booking_user_id ON booking(user_id);
CREATE INDEX idx_booking_event_id ON booking(event_id);
CREATE INDEX idx_booking_status ON booking(status);
CREATE INDEX idx_booking_expires_at ON booking(expires_at) WHERE status = 'PENDING';

-- Unique constraint to prevent double booking
CREATE UNIQUE INDEX idx_unique_active_seat_booking 
ON booking_item(seat_id, booking_id) 
WHERE booking_status IN ('PENDING', 'CONFIRMED');
```

### Caching Strategy

```typescript
// Use Redis for frequently accessed data
@Cacheable({ ttl: 300 }) // 5 minutes
async getEventById(id: string): Promise<Event> {
  return this.eventRepository.findOne({ where: { id } });
}
```

## Common Commands

```bash
# Start development
docker-compose up -d                    # Start infrastructure
nx serve api-gateway                    # Start gateway
nx serve catalog-service                # Start catalog
nx serve booking-service                # Start booking
nx serve payment-service                # Start payment

# Generate code
nx g @nx/nest:module booking --project=booking-service
nx g @nx/nest:service booking --project=booking-service
nx g @nx/nest:controller booking --project=booking-service

# Database
nx run catalog-service:migration:generate --name=CreateEventsTable
nx run catalog-service:migration:run

# Build
nx build api-gateway --prod
nx affected:build                       # Build affected projects
```

## Spec Kit Workflow

This project uses **Github Spec Kit** for Spec-Driven Development (SDD) to manage specifications and tasks.

### Directory Structure

```
eventix/
├── memory/
│   └── constitution.md        # Project rules & standards
├── specs/
│   └── {feature}/
│       ├── spec.md            # Feature specification (WHAT)
│       ├── plan.md            # Technical plan (HOW)
│       ├── data-model.md      # Database design
│       ├── research.md        # ADRs & technical decisions
│       └── tasks.md           # Implementation tasks
```

### Workflow Commands

```
# 1. Create new specification
/specify - Describe feature → Generate spec.md

# 2. Create technical plan
/plan - Review spec → Generate plan.md, data-model.md

# 3. Generate task list
/tasks - Review plan → Generate tasks.md

# 4. Implement tasks
Follow tasks.md checklist
```

### When Working on Features

1. **Read `constitution.md`** - Understand project standards
2. **Read `spec.md`** - Understand requirements
3. **Read `plan.md`** - Understand technical approach
4. **Follow `tasks.md`** - Implement step by step
5. **Update `research.md`** - Document decisions

### Current Specs

| Module | Status | Location |
|--------|--------|----------|
| Booking Core | Draft | `specs/booking-core/` |

---

## Spec Kit Prompt Templates

### 1. `/specify` - Define WHAT & WHY

Use when starting a new feature. Focus on business requirements, NOT technical details.

```
/specify

Feature: [Feature Name]

## Context
[Brief background about why this feature is needed]

## User Stories
- As a [role], I want to [action] so that [benefit]
- As a [role], I want to [action] so that [benefit]

## Acceptance Criteria
- [ ] Criteria 1
- [ ] Criteria 2

## Scope
- In scope: [what's included]
- Out of scope: [what's NOT included]

## Edge Cases
- What happens if [scenario]?
- How should system behave when [condition]?
```

**Example:**
```
/specify

Feature: Seat Reservation System

## Context
Users need to reserve seats for events with high concurrency support.

## User Stories
- As a customer, I want to select and lock seats so no one else can book them
- As a customer, I want 10 minutes to complete payment after reserving

## Acceptance Criteria
- [ ] Seats locked for 10 minutes after selection
- [ ] No double booking allowed
- [ ] Auto-release if payment not completed

## Scope
- In scope: Seat locking, expiration, booking lifecycle
- Out of scope: Actual payment processing, notifications
```

---

### 2. `/plan` - Define HOW

Use after spec is approved. Focus on technical implementation.

```
/plan

Review the spec at: specs/[feature]/spec.md

## Technical Constraints
- Stack: [technologies to use]
- Must integrate with: [existing systems]
- Performance requirements: [metrics]

## Questions to Address
- How will [component] communicate with [other component]?
- What database schema is needed?
- What are the API contracts?

## Specific Requirements
- Use [pattern/library] for [purpose]
- Follow [architecture] pattern
- Ensure [constraint]
```

**Example:**
```
/plan

Review the spec at: specs/booking-core/spec.md

## Technical Constraints
- Stack: NestJS + TypeORM + PostgreSQL + Redpanda
- Must integrate with: Catalog Service, Payment Service
- Performance: Handle 1000 concurrent booking attempts

## Questions to Address
- How to prevent race conditions on seat booking?
- What events to publish/consume?
- Database schema for bookings?

## Specific Requirements
- Use pessimistic locking for seat reservation
- Follow Clean Architecture pattern
- Ensure idempotency for event consumers
```

---

### 3. `/tasks` - Break Down Work

Use after plan is approved. Generate actionable task list.

```
/tasks

Review the plan at: specs/[feature]/plan.md

## Sprint Structure
- Sprint duration: [X weeks]
- Number of sprints: [Y]

## Task Requirements
- Break into small, implementable chunks
- Include estimates
- Define dependencies between tasks
- Group by sprint/phase

## Priority
- Must have: [critical features]
- Should have: [important but not critical]
- Nice to have: [can be deferred]
```

**Example:**
```
/tasks

Review the plan at: specs/booking-core/plan.md

## Sprint Structure
- Sprint duration: 2 weeks
- Number of sprints: 3

## Task Requirements
- Each task should be completable in < 1 day
- Include setup tasks first
- Group database tasks together

## Priority
- Must have: Create booking, seat locking, payment handling
- Should have: Expiration job, error handling
- Nice to have: API documentation, health checks
```

---

### 4. `/implement` - Execute Tasks

Use when ready to code. Work through tasks systematically.

```
/implement

Working on: specs/[feature]/tasks.md

## Current Task
Task [X.Y.Z]: [Task description]

## Context
- Previous completed: [what's done]
- Depends on: [prerequisites]

## Instructions
- Read constitution.md for coding standards
- Follow the plan.md architecture
- Update task status when complete

## Constraints
- Do NOT create test files (testing deferred)
- Do NOT over-engineer
- Keep changes focused on this task only
```

**Example:**
```
/implement

Working on: specs/booking-core/tasks.md

## Current Task
Task 1.4.3: Create Booking entity with TypeORM

## Context
- Database config is ready
- BookingStatus enum is created

## Instructions
- Follow entity structure in constitution.md
- Include all columns from data-model.md
- Add domain methods (confirm, cancel, isExpired)

## Constraints
- Do NOT create test files
- Do NOT add features not in spec
```

---

### 5. `/analyze` - Check Consistency

Use periodically to verify specs are consistent.

```
/analyze

Check the following for consistency:
- specs/[feature]/spec.md
- specs/[feature]/plan.md
- specs/[feature]/data-model.md
- memory/constitution.md

## Verify
- [ ] Plan addresses all spec requirements
- [ ] Data model supports all use cases
- [ ] No conflicts with constitution rules
- [ ] Tasks cover the entire plan
```

---

### Quick Reference

| Command | When to Use | Output |
|---------|-------------|--------|
| `/specify` | New feature | `spec.md` |
| `/plan` | After spec approved | `plan.md`, `data-model.md` |
| `/tasks` | After plan approved | `tasks.md` |
| `/implement` | Ready to code | Actual code |
| `/analyze` | Periodically | Consistency report |

### Pro Tips

1. **Be Specific**: Vague prompts = vague outputs
2. **One Thing at a Time**: Don't mix /specify with /plan
3. **Reference Files**: Always point to existing specs
4. **Iterate**: Review outputs and refine prompts
5. **Context Matters**: Include relevant constraints upfront

## References

- [BRD](./BUSINESS%20REQUIREMENTS%20DOCUMENT%20(BRD).md) - Business Requirements
- [SAD](./SYSTEM%20ARCHITECTURE%20DESIGN%20(SAD).md) - System Architecture Design
- [Constitution](./memory/constitution.md) - Project Standards
- [Booking Spec](./specs/booking-core/spec.md) - Core Booking Specification
- [NestJS Docs](https://docs.nestjs.com)
- [Nx Docs](https://nx.dev)
- [TypeORM Docs](https://typeorm.io)
- [Redpanda Docs](https://docs.redpanda.com)

